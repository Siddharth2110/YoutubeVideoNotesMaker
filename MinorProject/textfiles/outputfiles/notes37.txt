 Tip 7 Use Better Data Structures  Algorithms  No kidding. Using better data structures and algorithms will alwaysoutperform any optimizations mentioned in Tips 1-6 above. If you are sure that you have written your fastest Complete Searchcode, but it is still judged as TLE, abandon the Complete Searchapproach. Remarks About Complete Search in Programming ContestsThe main source of the Complete Search material in this chapteris the USACO training gateway 48. We have adopted the name Complete Search rather than Brute-Force with its negative connotations as we believe that someComplete Search solutions can be clever and fast. We feel that the term clever Brute-Force is also a little self-contradictory.  dictory.  dictory.  dictory. If a problem is solvable by Complete Search, it will also be clearwhen to use the iterative or recursive backtracking approaches. Iterative approaches are used when one can derive the differentstates easily with some formula relative to a certain counter andalmost all states have to be checked, e.g. scanning all the indicesof an array, enumerating almost all possible subsets of a small set,generating almost all permutations, etc. Recursive Backtracking is used when it is hard to derive thedifferent states with a simple index andor one also wants toheavily prune the search space, e.g. the 8-queens chess problem. If the search space of a problem that is solvable with CompleteSearch is large, then recursive backtracking approaches that allowearly pruning of infeasible sections of the search space are usuallyused.    ed. Pruning in iterative Complete Searches is not impossible butusually difficult. The best way to improve your Complete Search skills is to solvemore Complete Search problems. We have provided a list of such problems, separated into severalcategories below. Please attempt as many as possible, especially those that arehighlighted with the must try  indicator. Later in Section 3.5, readers will encounter further examples ofrecursive backtracking, but with the addition of the memoizationtechnique.   Section 3.5, readers will encounter further examples ofrecursive backtracking, but with the addition of the memoizationtechnique. Note that we will discuss some more advanced search techniqueslater in Section 8.2,e.g. using bit manipulation in recursivebacktracking, harder state-space search, Meet in the Middle, ASearch, Depth Limited Search DLS, Iterative Deepening SearchIDS, and Iterative Deepening A IDA.3.3 Divide and Conquer Divide and Conquer abbreviated as DC is a problem-solvingparadigm in which a problem is made simpler by dividing it intosmaller parts and then conquering each part. The steps1. Divide the original problem into sub-problemsusually by half ornearly half2. Find sub-solutions for each of these sub-problemswhich arenow easier.  easier.  ier,3. If needed, combine the sub-solutions to get a complete solutionfor the main problem. We have seen examples of the DC paradigm in the previoussections of this book Various sorting algorithms e.g. Quick Sort,Merge Sort, Heap Sort and Binary Search in Section 2.2 utilize thisparadigm. The way data is organized in Binary Search Tree, Heap, SegmentTree, and Fenwick Tree in Section 2.3, 2.4.3, and 2.4.4 also reliesupon the DC paradigm.       paradigm.3.3.1 Interesting Usages of Binary SearchIn this section, we discuss the DC paradigm in the well-knownBinary Search algorithm. We classify Binary Search as a Divide and Conquer algorithmalthough one reference 40 suggests that it should be actuallyclassified as Decrease by-half and Conquer as it does not actuallycombine the result. We highlight this algorithm because many contestants know it, butnot many are aware that it can be used in many other non-obviousways.  usways.  .Binary Search The Ordinary UsageRecall that the canonical usage of Binary Search is searching for anitem in a static sortedarray. We check the middle of the sorted array to determine if it containswhat we are looking for. If it is or there are no more items to consider, stop. Otherwise, wecan decide whether the answer is to the left or right of the middleelement and continue searching.  earching.  arching. As the size of search space is halved in a binary fashion after eachcheck, the complexity of this algorithm is Olog n. In Section 2.2, wehave seen that there are built-in library routines for this algorithm,e.g. the C STL algorithmlower bound and the JavaCollections.binarySearch. This is not the only way to use binary search. The pre-requisite forperforming a binary searcha static sorted sequence array orvectorcan also be found in other uncommon data structures suchas in the root-to-leaf path of a tree not necessarily binary norcomplete that satisfies the min heap property. This variant isdiscussed below.  or there are no more items to consider, stop. Otherwise, wecan decide whether the answer is to the left or right of the middleelement and continue searching. As the size of search space is halved in a binary fashion after eachcheck, the complexity of this algorithm is Olog n. In Section 2.2, wehave seen that there are built-in library routines for this algorithm,e.g. the C STL algorithmlower bound and the JavaCollections.binarySearch. This is not the only way to use binary search. The pre-requisite forperforming a binary searcha static sorted sequence array orvectorcan also be found in other uncommon data structures suchas in the root-to-leaf path of a tree not necessarily binary norcomplete that satisfies the min heap property. This variant isdiscussed below.  