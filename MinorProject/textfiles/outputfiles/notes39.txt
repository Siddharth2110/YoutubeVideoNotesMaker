 Greedy An algorithm is said to be greedy if it makes the locally optimalchoice at each step with the hope of eventually reaching the globallyoptimal solution.In some cases, greedy worksthe solution is short and runsefficiently. For many others, however, it does not. As discussed in other typicalComputer Science textbooks, e.g. 7, 38, a problem must exhibitthese two properties in order for a greedy algorithm to work1. It has optimal sub-structures.Optimal solution to the problem contains optimal solutions to thesub-problems.2. It has the greedy property difficult to prove in time-criticalcontest environment!.If we make a choice that seems like the best at the moment andproceed to solve the remaining subproblem, we reach the optimalsolution.      . We will never have to reconsiderour previous choices.3.4.1 ExamplesCoin Change - The Greedy VersionProblem description Given a target amount V cents and a list ofdenominations of n coins, i.e. we have coinValuei in cents for cointypes i 0..n-1, what is the minimum number of coins that wemust use to represent amount V  Assume that we have anunlimited supply of coins of any type.  e.  e.  e. Example If n  4, coinValue  25, 10, 5, 1 cents6, and we want torepresent V  42 cents, we can use this Greedy algorithm Select the largest coin denomination which is not greater than theremaining amount, i.e. 42-25  17 3 17-107  7-5252-11 1-1  0, a total of 5 coins. This is optimal. The problem above has the two ingredients required for asuccessful greedy algorithm It has optimal sub-structures. We have seen that in our quest to represent 42 cents, we used2510511.    511. This is an optimal 5-coin solution to the original problem!Optimal solutions to sub-problem are contained within the 5-coinsolution, i.e. a. To represent 17 cents, we can use 10511 part of the solutionfor 42 cents,b. To represent 7 cents, we can use 511 also part ofthe solution for 42 cents, etc It has the greedy property Given every amount V, we can greedilysubtract from it the largest coin denomination which is not greaterthan this amount V.t can be proven not shown here for brevity that using any otherstrategies will not lead to an optimal solution, at least for this set ofcoin denominations.  ations.  tions. However, this greedy algorithm does not work for all sets of coindenominations. Take for example 4, 3, 1 cents. To make 6 cents with that set, agreedy algorithm would choose 3 coins 4, 1, 1 instead of theoptimal solution that uses 2 coins 3, 3. The general version of this problem is revisited later in Section3.5.2 Dynamic Programming. Remarks About Greedy Algorithm in Programming ContestsIn this section, we have discussed three classical problems solvablewith Greedy algorithms Coin Change the special case, Load Balancing, and IntervalCovering.  vering.  vering.  Covering. For these classical problems, it is helpful to memorize theirsolutions for this case, ignore that we have said earlier in thechapter about not relying too much on memorization. We have alsodiscussed an important problem solving strategy usually applicableto greedy problems Sorting the input data to elucidate hidden greedy strategies. There are two other classical examples of Greedy algorithms in thisbook, e.g. Kruskals and Prims algorithm for the MinimumSpanning Tree MST problem see Section 4.3 and Dijkstrasalgorithm for the Single-Source Shortest Paths SSSP problem seeSection 4.4.3.    4.4.3. There are many more known Greedy algorithms that we havechosen not to discuss in this book as they are too problem specificand rarely appear in programming contests, e.g. Huffman Codes 7,38, Fractional Knapsack 7, 38, some Job Scheduling problems, etc. However, todays programming contests both ICPC and IOl rarelyinvolve the purely canonical versions of these classical problems. Using Greedy algorithms to attack a non classical problem isusually risky. A Greedy algorithm will normally not encounter the TLE responseas it is often lightweight, but instead tends to obtain WA verdicts.  ts. Proving that a certain non-classical problem has optimal sub-structure and greedy property during contest time may be difficultor time consuming, so a competitive programmer should usually usethis rule of thumbIf the input size is small enough to accommodate the timecomplexity of either Complete Search or Dynamic Programmingapproaches see Section 3.5, then use these approaches as both willensure a correct answer. Only use a Greedy algorithm if the inputsize given in the problem statement are too large even for the bestComplete Search or DP algorithm.  