 Top-Down versus Bottom-Up DP Although both styles use tables, the way the bottom-up DP table isfilled is different to that of the top-down DP memo table. In the top-down DP, the memo table entries are filled as neededthrough the recursion itself.In the bottom-up DP, we used a correct DP table filling order tocompute the values such that the previous values needed to processthe current cell have already been obtained. This table filling order is the topological order of the implicit DAGthis will be explained in more detail in Section 4.7.1 in therecurrence structure. For most DP problems, a topological order can be achieved simplywith the proper sequencing of some nested loops. For most DP problems, these two styles are equally good and thedecision to use a particular DP style is a matter of preference. However, for harder DP problems, one of the styles can be betterthan other.    her.Displaying the Optimal Solution Many DP problems request only for the value of the optimalsolution like the UVa 11450 above. However, many contestants are caught off-guard when they arealso required to print the optimal solution. We are aware of two ways to do this. The first way is mainly used in the bottom-up DP approach which isstill applicable for top-down DPs where we store the predecessorinformation at each state. If there are more than one optimal predecessors and we have tooutput all optimal solutions, we can store those predecessors in alist.  .  .  are more than one optimal predecessors and we have tooutput all optimal solutions, we can store those predecessors in alist. Once we have the optimal final state, we can do backtracking fromthe optimal final state and follow the optimal transitions recordedat each state until we reach one of the base cases. If the problem asks for all optimal solutions, this backtrackingroutine will print them all. However, most problem authors usually set additional outputcriteria so that the selected optimal solution is unique for easierjudging. Example See Figure 3.8, bottom. The optimal final state is reachable21. The predecessor of this optimal final state is state reachable12.We now backtrack to reachable12. Next, see Figure 3.8, middle.  middle. The predecessor of state reachable12is state reachable012. We then backtrack to reachable012. Asthis is already one of the initial base states at the first row, we knowthat an optimal solution is 2012  price 8, then 122  price10, then 241  price 1. However, as mentioned earlier in the problem description, thisproblem may have several other optimal solutions, e.g. We can also follow the path reachable21  reachable16 reachable016 which represents another optimal solution2016  price 4, then 16-6  price 10, then 641  price 5. The second way is applicable mainly to the top-down DP approachwhere we utilize the strength of recursion and memoization to do thesame job.   e job.   b. Using the top-down DP code shown in Approach 4 above, we willadd another function void print shopint money,int g that has thesame structure as int shopint money, int g except that it uses thevalues stored in the memo table to reconstruct the solution. Asample implementation that only prints out one optimalsolution is shown belowClassical Examples The problem UVa 11450 - Wedding Shopping above is a relativelyeasy non-classical DP problem, where we had to come up with thecorrect DP states and transitions by ourself. However, there are many other classical problems with efficient DPsolutions, i.e. Their DP states and transitions are well-known.  n.  . Therefore, such classical DP problems and their solutions should bemastered by every contestant who wishes to do well in ICPC or IOI! Inthis section, we list down six classical DP problems and theirsolutions. Note Once you understand the basic form of these DP solutions,try solving the programming exercises that enumerate their variants.Max 1D Range Sum Abridged problem statement of UVa 507 - Jill Rides Again Given aninteger array A containing n  20K non-zero integers, determine themaximum 1D range sum of A. In other words, find the maximum Range Sum Query RSQbetween two indices i and j in 0..n-1, that is Ai  Ai1  Ai2...Aj also see Section 2.4.3 and 2.4.4.   2.4.4.  also see Section 2.4.3 and 2.4.4. A Complete Search algorithm that tries all possible On2 pairs of iand j, computes the required RSQi, j in On, and finally picks themaximum one runs in an overall time complexity of On3. With n up to 20K, this is a TLE solution.In Section 2.4.4, we have discussed the following DP strategy Pre-process array A by computing Ali  Ai-1 i 1..n-1 so that Aicontains the sum of integers in subarray AO..i.We can now compute RSQi, j in O1 RSQO, j  Aj and RSQi, j Afj - Ai-1 i 0. With this, the Complete Search algorithm abovecan be made to run in On2. For n up to 20K, this is stilla TLE approach. However, this techniqueis still useful in other cases see the usage of this 1D Range Sum inSection 8.4.2.  ction 8.4.2.  on 8.4.2. The key idea of Kadanes algorithm is to keep a running sum of theintegers seen so far and greedily reset that to 0 if the running sumdips below O. This is because re-starting from 0 is always better than continuingfrom a negative running sum. Kadanes algorithm is the required algorithm to solve this UVa 507problem as n S 20K.  0K.  