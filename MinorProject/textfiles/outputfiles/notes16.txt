 Competitive ProgrammingThe core directive in Competitive Programming is thisGiven well-known Computer Science CS problems, solvethem as quickly as possible!.Lets digest the terms one by one. The term well-known CSproblems implies that in competitive programming, we aredealing with solved CS problems and not research problemswhere the solutions are still unknown. Some people at least the problem author have definitelysolved these problems before.To solve them implies that we1 must push our CS knowledgeto acertain required level so that we can produce workingcode that can solve these problems tooat least in terms ofgetting the same output as the problem author using theproblem authors secret2 test data within the stipulated timelimit.  it.  to solve the problem as quickly as possible is where thecompetitive element liesspeed is a very natural goal in humanbehaviour.Please note that being well-versed in competitive programming isnot the end goal, but only a means to an end. The true end goal is to produce all-rounder computer scientistsprogrammers who are much readier to produce better software andto face harder CS research problems in the future. The founders of the ACM International Collegiate ProgrammingContest ICPC have this vision and we, the authors, agree with it.With this book, we play our little role in preparing the current andthe future generations to be more competitive in dealing with well-known CS problems frequently posed in the recent ICPCs and theInternational Olympiad in Informatics IO1s.  .Tips to be CompetitiveIf you strive to be like competitive programmers D or E asillustrated abovethat is, if you want to be selected viaprovincialstate  national team selections to participate andobtain a medal in the IOI.or to be one of the team members that represents your Universityin the ACM ICPCor to do well in other programming conteststhen this book isdefinitely for you!  bsequent chapters, you will learn everything from thebasic to the intermediate or even to the advanced3 data structuresand algorithms that have frequently appeared in recentprogramming contests, compiled from many sources.You will not only learn the concepts behind the data structures andalgorithms, but also how to implement them efficiently and applythem to appropriate contest problems.On top of that, you will also learn many programming tips derivedfrom our own experiences that can be helpful in contest situations.We start this book by giving you several general tips below  w  e Code Faster!No kidding! Although this tip may not mean much as ICPC andespecially Ol are not typing contests, we have seen Rank i andRank i 11CPC teams separated only by a few minutes andfrustrated IOI contestants who miss out on salvaging importantmarks by not being able to code a last-minute brute force solutionproperly.When you can solve the same number of problems as yourcompetitor, it will then be down to coding skill your ability toproduce concise and robust code and ... typing speed.Try this typing test at httpwww.typingtest.com and follow theinstructions there on how to improve your typing skill.Stevens is 85-95 wpm and Felixs is 55-65 wpm. If your typingspeed is much less than these numbers, please take this tipseriously!   On top of being able to type alphanumeric characters quickly andcorrectly, you will also need to familiarize your fingers with thepositions of the frequently used programming language charactersparentheses  or  or square brackets  or angle brackets , thesemicolon  and colon , single quotes  for characters, doublequotes  for strings, the ampersand , the vertical bar or the pipe, the exclamation mark !, etc.    ckly Identify Problem TypesThe classification in Table 1.1 is adapted from 48 and by nomeans complete. Some techniques, e.g. sorting, are not classifiedhere as they are trivial and usually used only as a sub-routine inabigger problem.We do not include recursion as it is embedded in categorieslike recursive backtracking or Dynamic Programming.We also omit data structures as the usage of efficient datastructure can be considered to be integral for solving harderproblems. Of course, problems sometimes require mixedtechniques A problem can be classified into more than one type.For example, Floyd Warshalls algorithm is both a solutionfor the All-Pairs Shortest Paths APSP, Section 4.5 graph problemand a Dynamic Programming DP algorithm Section 3.5.  5.   Kruskals algorithms are both solutions for the MinimumSpanning Tree MST, Section 4.3 graph problem and Greedyalgorithms Section 3.4.In Section 8.4, we will discuss harder problems that require morethan one algorithms andor data structures to be solved. In the near future, these classifications may change. Onesignificant example is Dynamic Programming.This technique was not known before 1940s, nor frequently usedin ICPCs or Ols before mid 1990s, but it is considered a definiteprerequisite today.As an illustration There were  3 DP problems out of 11 in therecent ICPC World Finals 2010.  10.  