 The cumulative frequency table can also be used as a solution tothe Range Sum Query RSQ problem mentioned in Exercise2.4.3.2. It stores RSQ1, i Vi E1..n where n is the largest integerindexscore30.In the example above, we have n  10, RSQ1, 1  0, RSQ1, 2  1,...,RSQ1, 6 7,..., RSQ1, 8  10, ..., and RSQ1, 10  11. Wecan then obtain the answer to the RSQ for an arbitrary range RSQi,j when i 1 by subtracting RSQ1, j - RSQ1, i- 1. For example, RSQ4, 6  RSQ1, 6 - RSQ1, 3  7-16. If thefrequencies are static, then the cumulative frequency table as inTable 2.1 can be computed efficiently with a simple On loop. First, set cf1  f1. Then, for i 2..n, compute cfi  cfi - 1  fli. This will bediscussed further in Section 3.5.2. However, when the frequencies are frequently updated increasedor decreased and the RSQs are frequently asked afterwards, it isbetter to use a dynamic data structure.  ture.  Instead of using a Segment Tree to implement a dynamiccumulative frequency table, we can implement the far simplerFenwick Tree instead compare the source code for bothimplementations, provided in this section and in the previousSection 2.4.3. This is perhaps one of the reasons why the Fenwick Tree iscurrently included in the IOI syllabus 20. Fenwick Tree operations are also extremely efficient as they usefast bit manipulation techniques see Section 2.2.In this section, we will use the function LSOnei which is actuallyi  -i extensively, naming it to match its usage in the originalpaper 18.  er 18.  18.In Section 2.2, we have seen that the operation i  -i producesthe first Least Significant One-bit in i. The Fenwick Tree is typically implemented as an array we use avector for size flexibility. The Fenwick Tree is a tree that is indexed by the bits of its integerkeys. These integer keys fall within the fixed range 1..nskipping31index 0. In a programming contest environment, n can approach  1M sothat the Fenwick Tree covers the range 1..1Mlarge enough formany practical contest problems.  lems.  lems.  amming contest environment, n can approach  1M sothat the Fenwick Tree covers the range 1..1Mlarge enough formany practical contest problems.In Table 2.1 above, the scores 1..10 are the integer keys in thecorresponding array with size n  10 and m  11 data points. Let thename of the Fenwick Tree array be ft. Then, the element at index i is responsible for elements in therange i-LSOnei1..i and fti stores the cumulative frequency ofelements fi-LSOnei1, i-LSOnei2, i-LSOnei3, .., i.n Figure 2.11, the value of fti is shown in the circle above index iand the range i-LSOnei1..i is shown as a circle and a bar if therange spans more than one index above index i. We can see that ft4  2 is responsible for range 4-41..4 1..4, ft6 5 is responsible for range 6-21..6  5..6, ft7  2 isresponsible for range 7-11..7  7..7, ft8  10 is responsible forrange 8-81..8  1..8 etc32.   etc32.   etc32.  .8 etc32. With such an arrangement, if we want to obtain the cumulativefrequency between 1..b, i.e. rsqb, we simply add ftb, ftb,ftb, ... until index bi is 0. This sequence of indices is obtained via subtracting the LeastSignificant One-bit via the bit manipulation expression b  b -LSOneb. Iteration of this bit manipulation effectively strips off the leastsignificant one-bit of b at each step. As an integer b only has Olog b bits, rsqb runs in Olog n timewhen b  n. In Figure 2.11, rsq6  ft6  ft4 5 2  7. Noticethat indices 4 and 6 are responsible for range 1..4 and 5..6,respectively.   By combining them, we account for the entire range of 1..6. Theindices 6, 4, and 0 are related in their binary form b  610  1102can be transformed to b  410  1002 and subsequently to b 010  0002. With rsqb available, obtaining the cumulative frequencybetween two indices a..b where a !1 is simple, just evaluatersqa, b  rsqb - rsqa - 1. For example, if we want to compute rsq4, 6, we can simplyreturn rsq6 - rsq3  52 - 01  7 - 1  6. Again, this operationruns in O2 x log b  Olog n time when b  n. Figure 2.12 displaysthe value of rsq3.   rsq3.  . When updating the value of the element at index k by adjusting itsvalue by v note that v can be either positive or negative, i.e. callingadjustk, v, we have to update ftk, ftk, ftk, ... until index kiexceeds n.This sequence of indices are obtained via this similar iterative bitmanipulation expression k  k  LSOnek. Starting from any integer k, the operation adjustk, v will take atmost Olog n steps until k  n.   n.  . In Figure 2.13, adjust5, 1 will affect add 1 to ftk at indices k 510  1012, k  1012  0012  1102  610, and k  1102 0102  10002  810 via the expression given above. Notice that if you project a line upwards from index 5 in Figure2.13, you will see that the line indeed intersects the ranges underthe responsibility of index 5, index 6, and index 8.  index 8.  