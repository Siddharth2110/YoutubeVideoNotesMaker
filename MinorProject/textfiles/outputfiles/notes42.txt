 Approach 5 Bottom-Up DP Accepted There is another way to implement a DP solution often referred toas the bottom-up DP. This is actually the true form of DP as DP was originally known asthe tabular method computation technique involving a table. The basic steps to build bottom-up DP solution are as follows Determine the required set of parameters that uniquely describethe problem the state. This step is similar to what we havediscussed in recursive backtracking and top-down DP earlier. If there are N parameters required to represent the states, preparean N dimensional DP table, with one entry per state.This is equivalent to the memo table in top-down DP. However, there are differences. In bottom-up DP, we only need toinitialize some cells of the DP table with known initial values thebase cases.  ases.  es. Recall that in topdown DP, we initialize the memo table completelywith dummy values usually -1 to indicate that we have not yetcomputed the values. Now, with the base-case cellsstates in the DP table already filled,determine the cellsstates that can be filled next the transitions. Repeat this process until the DP table is complete. For the bottom-up DP, this part is usually accomplished throughiterations, using loops more details about this later. For UVa 11450, we can write the bottom-up DP as follow Wedescribe the state of a subproblem with two parameters The current garment g and the current money.  y.   money. This state formulation is essentially equivalent to the state in thetop-down DP above, except that we have reversed the order tomake g the first parameter thus the values of g are the row indicesof the DP table so that we can take advantage of cache-friendly row-major traversal in a 2D array, see the speed-up tips in Section 3.2.3. Then, we initialize a 2D table boolean matrix reachableg moneyof size 20 x 201. Initially, only cellsstates reachable by buying any of the models ofthe first garment g  O are set to true in the first row. Lets use test case A above as example. In Figure 3.8, top, the only columns 20-6  14, 20-4  16, and 20-8 12 in row 0 are initially set to true.     to true. Now, we loop from the second garment g  1 second row to thelast garment g  C-1  3-1  2 third and last row in row-major orderrow by row. If reachableg-1 money is true, then the next statereachablegmoney-p where p is the price of a model of currentgarment g is also reachable as long as the second parametermoney is not negative. See Figure 3.8, middle, where reachable016 propagates toreachable116-5 and reachable116-10 when the model withprice 5 and 10 in garment g  1 is bought, respectivelyreachable012 propagates to reachable112-10 when the modelwith price 10 in garment g  1 is bought, etc.  etc.  etc.  ht, etc. We repeat this table filling process row by row until we are donewith the last row12. Finally, the answer can be found in the last row when g  C-1. Findthe state in that row that is both nearest to index 0 and reachable. In Figure 3.8, bottom, the cell reachable21 provides the answer. This means that we can reach state money  1 by buying somecombination of the various garment models. The required final answer is actually M - money, or in this case, 20-119., The answer is no solution if there is no state in the last row thatis reachable where reachableC-1money is set to true.    rue. We provide our implementation below for comparison with thetop-down version. There is an advantage for writing DP solutions in the bottom-upfashion. For problems where we only need the last row of the DP table or,more generally, the last updated slice of all the states to determinethe solutionincluding this problem, we can optimize the memoryusage of our DP solution by sacrificing one dimension in our DPtable. For harder DP problems with tight memory requirements, thisspace saving trick may prove to be useful, though the overall timecomplexity does not change.  .  .  nge. Lets take a look again at Figure 3.8. We only need to store tworows, the current row we are processing and the previous row wehave processed. To compute row 1, we only need to know the columns in row 0 thatare set to true in reachable. To compute row 2, we similarly only need to know the columns inrow 1 that are set to true in reachable. In general, to compute row g, we only need values from theprevious row g - 1. So, instead of storing a boolean matrix reachablegmoney of size20 x 201, we can simply store reachable2money of size 2 x 201.   x 201. We can use this programming trick to reference one row as theprevious row and another row as the current row e.g. prev  0,cur  1 and then swap them e.g. now prev  1, cur  0 as wecompute the bottom-up DP row by row. Note that for this problem, the memory savings are not significant. For harder DP problems, for example where there might bethousands of garment models instead of 20, this space saving trickcan be important.    