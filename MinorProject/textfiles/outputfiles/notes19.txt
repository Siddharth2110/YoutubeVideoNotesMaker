 Tip 5 Master the Art of Testing CodeYou thought you nailed a particular problem. You identified itsproblem type, designed the algorithm for it, verified that thealgorithm with the data structures it uses will run in time 4ndwithin memory limits by considering the time and spacecomplexity, and implemented the algorithm, but your solution isstill not Accepted AC. Depending on the programming contest, you may or may not getcredit for solving the problem partially. In ICPC, you will only getpoints for a particular problem if your teams code solves all thesecret test cases for that problem. Other verdicts such asPresentation Error PE, Wrong Answer WA, Time LimitExceeded TLE, Memory Limit Exceeded MLE, Run Time ErrorRTE, etc. do not increase your teams points.  ints.  s. In current IOI 2010-2012, the subtask scoring system is used.Test cases are grouped into subtasks, usually simpler variants ofthe original task with smaller input bounds. You will only be credited for solving a subtask if your code solvesall test cases init. You are given tokens that you can usesparingly throughout the contest to view the judges evaluationof your code.  e.In either case, you will need to be able to design good,comprehensive and tricky test cases. The sample input-outputgiven in the problem description is by nature trivial and thereforeusually not a good means for determining the correctness of yourcode. Rather than wasting submissions and thus accumulating time orscore penalties in ICPC or tokens in IOI, you may want to designtricky test cases for testing your code on your own machines. Ensure that your code is able to solve them correctly otherwise,there is no point submitting your solution since it is likely to beincorrectunless you want to test the test data bounds.  ds. Some coaches encourage their students to compete with eachother by designing test cases. If student As test cases can breakstudent Bs code, then A will get bonus points. You may want totry this in your team training . Here are some guidelines for designing good test cases from ourexperience. These are typically the steps that have been taken by problemauthors.  thors.  thors.  hors.1. Your test cases should include the sample test cases since thesample output is guaranteed to be correct. Use fc in Windows ordiff in UNIX to check your codes output when given the sampleinput against the sample output. Avoid manual comparison as humans are prone to error and arenot good at performing such tasks, especially for problems withstrict output formats e.g. blank line between test cases versusafter every test cases.To do this, copy and paste the sample input and sample outputfrom the problem description, then save them to files named asinput and output or anything else that is sensible.  ible. Then, after compiling your program lets assumethe executables name is the g default a.out, execute it withan O redirection a.out  input  myoutput. Finally, execute diff myoutput output to highlight anypotentially subtle differences, if any exist.  t.  oblems with multiple test cases in a single run seeSection 1.3.2, you should include two identical sample test casesconsecutively in the same run. Both must output the same knowncorrect answers. This helps to determine if you have forgotten to initialize anyvariablesif the first instance produces the correct answer butthe second one does not, it is likely that you have not reset yourvariables.3. Your test cases should include tricky corner cases. Think like theproblem author and try to come up with the worst possible inputfor your algorithm by identifying cases that are hidden or impliedwithin the problem description. These cases are usually included in the judges secret test casesbut not in the sample input and output.  ases typically occur at extreme values such as N 0, N1, negative values, large final andor intermediate values thatdoes not fit 32-bit signed integer, etc.4. Your test cases should include arge cases. Increase the inputsize incrementally up to the maximum input bounds stated in theproblem description. Use large test cases with trivial structuresthat are easy to verify with manual computation and largerandom test cases to test if your code terminates in time and stillproduces reasonable output since the correctness would bedifficult to verify here. Sometimes your program may work for small test cases, butproduces wrong answer, crashes, or exceeds the time limit whenthe input size increases.If that happens, check for overflows, out of bound errors, orimprove your algorithm.  m.  m.  m.  