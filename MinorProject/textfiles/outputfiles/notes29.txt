 In this section, we will use 5 disjoint sets 0, 1, 2, 3, 4 to illustratethe usage of this data structure. We initialize the data structure such that each item is a disjoint setby itself with rank 0 and the parent of each item is initially set toitself. To unite two disjoint sets, we set the representative item root ofone disjoint set to be the new parent of the representative item ofthe other disjoint set. This effectively merges the two trees in the Union-Find Disjoint Setrepresentation. As such, unionSeti, j will cause both items i and jto have the same representative itemdirectly or indirectly. For efficiency, we can use the information contained in vi rank toset the representative item of the disjoint set with higher rank to bethe new parent of the disjoint set with lower rank, therebyminimizing the rank of the resulting tree.  ee.  ing tree. If both ranks are the same, we arbitrarily choose one of them asthe new parent and increase the resultant roots rank. This is theunion by rank heuristic. In Figure 2.6, top, unionSet0, 1 sets p0to 1 and rank1 to 1. In Figure 2.6, middle, unionSet2, 3 sets p2 to 3 and rank3 to 1. For now, lets assume that function findSeti simply callsfindSetpi recursively to find the representative item of a set,returning findSetpi whenever pi !i and i otherwise. In Figure 2.6, bottom, when we call unionSet4, 3, we haverankfindSet4  rank4  0 which is smaller than rankfindSet3 rank3  1, so we set p4  3 without changing the height of theresulting treethis is the union by rank heuristic  ristic at work. With the heuristic, the path taken from any node to therepresentative item by following the chain of parent links iseffectively minimized.In Figure 2.6, bottom, isSameSet0, 4 demonstrates anotheroperation for this data structure. This function isSameSeti, j simply calls findSeti and findSetjand checks if both refer to the same representative item. If they do,then i and j both belong to the same set.  ame set.  ame set.  t. Here, we see that findSet0  findSetp0  findSet1  1 is notthe same as findSet4 findSetp4  findSet3  3. Therefore itemO and item 4 belongs to different disjoint sets. There is a technique that can vastly speed up the findSetifunction Path compression. Whenever we find the representative root item of a disjoint setby following the chain of parent links from a given item, we can setthe parent of al items traversed to point directly to the root. Any subsequent calls to findSeti on the affected items will thenresult in only one link being traversed. This changes the structure of the tree to make findSeti moreefficient but yet preserves the actual constitution of the disjoint set.   set.  int set. Since this will occur any time findSeti is called, the combinedeffect is to render the runtime of the findSeti operation to run inan extremely efficient amortized OM x an time. In Figure 2.7, we demonstrate this path compression. First, we callunionSet0, 3. This time, we set p1  3 and update rank3  2. Now notice thatp0 is unchanged, i.e. pO  1. This is an indirect reference to the true representative item of theset, i.e. pO  1  p1  3.   p1  3.  3. Function findSeti will actually require more than one step totraverse the chain of parent links to the root. However, once it findsthe representative item, e.g. x for that set, it will compress thepath by setting pli x, i.e. findSet0 sets p0  3. Therefore, subsequent calls of findSeti will be just O1. Thissimple strategy is aptly named the path compression heuristic.Note that rank3  2 now no longer reflects the true height of thetree. This is why rank only reflects the upper bound of the actual heightof the tree.  .  .  reeIn this subsection, we will discuss a data structure which canefficiently answer dynamic range queries. One such range query is the problem of finding the index of theminimum element in an array within range i..j. This is morecommonly known as the Range Minimum Query RMQ problem. For example, given an array A of size n  7 below, RMQ1, 3  2, asthe index 2 contains the minimum element among A1, A2, andA3. To check your understanding of RMQ, verify that in the array Abelow, RMQ3, 4  4, RMQ0, 0  0, RMQO, 1  1, and RMQO, 6 5. For the next few paragraphs, assume that array Ais the same.    e several ways to implement the RMQ. One trivialalgorithm is to simply iterate the array from index i to j and reportthe index with the minimum value, but this will run in On time perquery. When n is large and there are many queries, such analgorithm may be infeasible.In this section, we answer the dynamic RMQ problem with aSegment Tree, which is another way to arrange data in a binary tree.There are several ways to implement the Segment Tree. Ourimplementation uses the same concept as the 1-based compactarray in the binary heap where we use vi our shortcut forvectorint st to represent the binary tree. Index 1 skipping index0 is the root and the left and right children of index p are index 2 x pand 2 x p  1 respectively also see Binary Heap discussion inSection 2.3. The value of stp is the RMQ value of the segmentassociated with index p.  