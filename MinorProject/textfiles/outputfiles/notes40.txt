  Having said that, it is increasingly true that problem authors tryto set the input bounds of problems that allow for Greedystrategies to be in an ambiguous range so that contestants cannotuse the input size to quickly determine the required algorithm! We have to remark that it is quite challenging to come up withnew non-classical Greedy problems. Therefore, the number of such novel Greedy problems used incompetitive programming is lower than that of Complete Search orDynamic Programming problems.Dynamic Programming Dynamic Programming from now on abbreviated as DP isperhaps the most challenging problem-solving technique amongthe four paradigms discussed in this chapter. Thus, make sure that you have mastered the material mentionedin the previous chapterssections before reading this section. Also, prepare to see lots of recursion and recurrence relations!  lations!  elations!The key skills that you have to develop in order to master DP arethe abilities to determine the problem states and to determine therelationships or transitions between current problems and theirsub-problems. We have used these skills earlier in recursive backtracking seeSection 3.2.2.In fact, DP problems with small input size constraints may alreadybe solvable with recursive backtracking.If you are new to DP technique, you can start by assuming thatthe top-down DP is a kind of intelligent or faster recursivebacktracking. In this section, we will explain the reasons why DP isoften faster than recursive backtracking for problems amenable toit.  le toit.  e new to DP technique, you can start by assuming thatthe top-down DP is a kind of intelligent or faster recursivebacktracking. In this section, we will explain the reasons why DP isoften faster than recursive backtracking for problems amenable toit. DP is primarily used to solve optimization problems and countingproblems. If you encounter a problem that says minimize this ormaximize that or count the ways to do that, then there is ahigh chance that it is a DP problem. Most DP problems inprogramming contests only ask for the optimaltotal value and notthe optimal solution itself, which often makes the problem easierto solve by removing the need to backtrack and produce thesolution. However, some harder DP problems also require the optimalsolution to be returned in some fashion. We will continually refine our understanding of DynamicProgramming in this section.  on.3.5.1 DP Illustration We will illustrate the concept of Dynamic Programming with anexample problem Uva 11450 - Wedding Shopping. The abridged problem statement Given different options foreach garment e.g. 3 shirt models, 2 belt models, 4 shoe models, . .. and a certain limited budget, our task is to buy one model ofeach garment. We cannot spend more money than the given budget, but wewant to spend the maximum possible amount. The input consists of two integers 1 M  200 and1sCs20,where M is the budget and Cis the number of garments that youhave to buy, followed by some information about the C garments.  .  .  garments. For the garment g 0..C-1, we will receive an integer 1  K  20which indicates the number of different models there are for thatgarment g, followed by K integers indicating the price of eachmodel 1..K of that garment g. The output is one integer that indicates the maximum amount ofmoney we can spend purchasing one of each garment withoutexceeding the budget. If there is no solution due to the small budget given to us, thensimply print no solution. The answer is then no solution because even if we buy all thecheapest models for each garment, the total price 451  10still exceeds our given budget M  9.  M  9.   M  9.In order for us to appreciate the usefulness of DynamicProgramming in solving the above-mentioned problem, letsexplore how far the other approaches discussed earlier willget us in this particular problem.Approach 1 Greedy Wrong AnswerSince we want to maximize the budget spent, one greedy ideathere are other greedy approacheswhich are also WA is to takethe most expensive model for each garment g which still fits ourbudget. For example in test case A above, we can choose the mostexpensive model 3 of garment g  0 with price 8 money is now 20-8  12, then choose the most expensive model 2 of garment g 1with price 10 money  12-10  2.  2.   2, and finally for the last garmentg  2, we can only choose model 1 with price 1 as the money wehave left does not allow us to buy the other models with price 3 or5. This greedy strategy works for test cases A and B above andproduce the same optimal solution 8101  19 and nosolution, respectively. It also runs very fast8 2020. . . 20 for a total of 20 times  400operations in the worst case.  se.  case. However, this greedy strategy does not work formany other test cases, such as this counter-example below testcase CTest case Cwith M12,C33 models of garment g0 6482 models of garment g15104 models of garment g231535The Greedy strategy selects model 3 of garment g  0 with price 8money  12-8  4,causing us to not have enough money to buy any model ingarment g  1, thus incorrectlyreporting no solution. One optimal solution is 453  12, whichuses up all of ourbudget. The optimal solution is not unique as 651  12 alsodepletes the budget.  