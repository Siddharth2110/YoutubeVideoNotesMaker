 Approach 2 Divide and Conquer Wrong Answer This problem is not solvable using the Divide and Conquerparadigm. This is because the sub-problems explained in the CompleteSearch sub-section below are not independent. Therefore, we cannot solve them separately with the Divide andConquer approach.Approach 3 Complete Search Time Limit Exceeded Next, lets see if Complete Search recursive backtracking can solvethis problem. One way to use recursive backtracking in this problem is to write afunction shopmoney, g with two parameters The current moneythat we have and the current garment g that we are dealing with. The pair money, g is the state of this problem. Note that the orderof parameters does not matter, e.g. g, money is also a perfectlyvalid state.  tate.  ate. Later in Section 3.5.3, we will see more discussion on how to selectappropriate states for a problem. We start with money  M and garment g  O. Then, we try allpossible models in garment g  0 a maximum of 20 models. If model i is chosen, we subtract model is price from money, thenrepeat the process in a recursive fashion with garment g  1 whichcan also have up to 20 models, etc. We stop when the model for the last garment g  C-1 hasbeen chosen. If money  0 before we choose a model from garment g  C-1, wecan prune the infeasible solution. Among all valid combinations, we can then pick the one thatresults in the smallest non-negative money. This maximizes the money spent, which is M - money.  y.  money. This solution works correctly, but it is very slow! Lets analyze theworst case time complexity.In the largest test case, garment g  0 has up to 20 modelsgarment g  1 also has up to 20 models and all garments includingthe last garment g  19 also have up to 20 models. Therefore, this Complete Search runs in 20 x 20x... x20operations in the worst case, i.e. 2020  a very large number. If we can only come up with this Complete Search solution, wecannot solve this problem.Approach 4 Top-Down DP AcceptedTo solve this problem, we have to use the DP concept as thisproblem satisfies the two prerequisites for DP to be applicable  le  le  ble This problem has optimal sub-structures. This is illustrated in the third Complete Search recurrence aboveThe solution for the sub-problem is part of the solution of theoriginal problem. In other words, if we select model i for garment g 0, for our final selection to be optimal, our choice for garments g land above must also be the optimal choice for a reduced budget ofM - price, where price refers to the price of model i. This problem has overlapping sub-problems. This is the key characteristic of DP! The search space of thisproblem is not as big as the rough 2020 bound obtained earlierbecause many sub-problems are overlapping!    ! Lets verify if this problem indeed has overlapping sub-problems.Suppose that there are 2 models in a certain garment g with thesame price p. Then, a Complete Search will move to the same sub-problemshopmoney - p, g  1 after picking either model! This situation will also occur if some combination of money andchosen models price causes money! - p1  money - p2 at the samegarment g. This willin a Complete Search solutioncause the same sub-problem to be computed more than once, an inefficient state ofaffairs!  !  !  affairs!So, how many distinct sub-problems a.k.a. states in DPterminology are there in this problem Only 201 x 20  4020. Thereare only 201 possible values for money 0 to 200 inclusive and 20possible values for the garment g 0 to 19 inclusive. Each sub-problem just needs to be computed once. If we can ensure this, we can solve this problem much faster. The implementation of this DP solution is surprisingly simple. If wealready have the recursive backtracking solution see therecurrencesa.k.a. transitions in DP terminology shown in theComplete Search approach above, we can implement the top-downDP by adding these two additional steps  al steps   steps Initialize10 a DP memo table with dummy values that are notused in the problem, e.g. -1. The DP table should have dimensions corresponding to theproblem states.At the start of the recursive function, check if this state has beencomputed before.a If it has, simply return the value from the DP memo table, O1.This the origin of the term memoization.b If it has not been computed, perform the computation as pernormal only once and then store the computed value in the DPmemo table so that further calls to this sub-problem state returnimmediately.  ediately. Analyzing a basic11 DP solution is easy. If it has M distinct states,then it requires OM memory space. If computing one state thecomplexity of the DP transition requires Ok steps, then the overalltime complexity is OkM. This UVa 11450 problem has M  201 x 20  4020 and k  20 as wehave to iterate through at most 20 models for each garment g.Thus, the time complexity is at most 4020 x 20  80400 operationsper test case, a very manageable calculation.We display our code below for illustration, especially for those whohave never coded a top-down DP algorithm before. Scrutinize thiscode and verify that it is indeed very similar to the recursivebacktracking code that you have seen in Section 3.2.  on 3.2.  