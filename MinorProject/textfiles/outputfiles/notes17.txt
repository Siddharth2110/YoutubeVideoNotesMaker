 Tip 3 Do Algorithm AnalysisOnce you have designed an algorithm to solve a particularproblem in a programming contest, you must then ask thisquestion Given the maximum input bound usually given inagood problem description, can the currently developedalgorithm, with its timespace complexity, pass thetimememory limit given for that particular problemSometimes, there are more than one way to attack a problem.Some approaches may be incorrect, others not fast enough,and yet others overkill. A good strategy is to brainstorm formany possible algorithms and then pick the simplest solutionthat works i.e. is fast enough to pass the time and memorylimit and yet still produce the correct answer4!.  mputers are quite fast and can process5 up to 100M or 108 1M  1, 000, 000 operations in a few seconds.You can use this information to determine if your algorithmwill run in time. For example, if the maximum input size n is100K or 105 1K  1, 000, and your current algorithm has atime complexity of On2, common sense or your calculatorwill inform you that 100K2 or 1010 is a very large number thatindicates that your algorithm will require on the order ofhundreds of seconds to run.You will thus need to devise a faster and also correctalgorithm to solve the problem. Suppose you find one that runswith a time complexity of On log2 n. Now, your calculator willinform you that 105 log2 105 is just 1.7 x 106 and commonsense dictates that the algorithm which should now run inunder a second will likely be able to pass the time limit.  .Suppose that you can only devise a relatively-simple-to-codealgorithm that runs with a horrendous time complexity ofOn4. This may appear to be an infeasible solution, but ifn s50, then you have actually solved the problem. You canimplement your On4 algorithm with impunity since 504 is just6.25M and your algorithm should still run in around a second.Note, however, that the order of complexity does notnecessarily indicate the actual number of operations that youralgorithm will require.  require. If each iteration involves a large number of operations manyfloating point calculations, or a significant number of constantsub-loops, or if your implementation has a high constant in itsexecution unnecessarily repeated loops or multiple passes, oreven IO or execution overhead, your code may takelonger to execute than expected. However, this will usually not be the case as the problemauthors should have designed the time limits so that a well-coded algorithm with a suitable time complexity will achieve anAC verdict.      t. By analyzing the complexity of your algorithm with the giveninput bound and the stated timememory limit, you can betterdecide whether you should attempt to implement youralgorithm which will take up precious time in the ICPCs andIOls, attempt to improve your algorithm first, or switch toother problems in the problem set. As mentioned in the preface of this book, we will not discussthe concept of algorithmic analysis in details. We assume thatyou already have this basic skill.  ll.  .There are a multitude of other reference books for example,the Introduction to Algorithms 7, Algorithm Design38, Algorithms 8, etc that will help you to understand thefollowing prerequisite conceptstechniques in algorithmicanalysis  isBasic time and space complexity analysis for iterative andrecursive algorithmsAn algorithm with k-nested loops of about n iterations each hasOnk complexity. If your algorithm is recursive with b recursive calls per leveland has L levels, the algorithm has roughly ObL complexity,but this is a only a rough upper bound. The actual complexitydepends on what actions are done per level and whetherpruning is possible. A Dynamic Programming algorithm or other iterative routinewhich processes a 2D n x n matrix in Ok per cell runs in Ok xn2 time. This is explained in further detail in Section 3.5.  n 3.5.  on 3.5. More advanced analysis techniquesProve the correctness of an algorithm especially for Greedyalgorithms in Section 3.4, to minimize your chance of gettingthe Wrong Answer verdict.  