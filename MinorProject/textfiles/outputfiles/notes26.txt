 Non-Linear DS with Built-in LibrariesFor some problems, linear storage is not the best way to organizedata.With the efficient implementations of non-linear data structuresshown below, you can operate on the data in a quicker fashion,thereby speeding up the algorithms that rely on them. For example, if you need a dynamic11 collection of pairs e.g. key value pairs, using C STL map below can provide you Olog nperformance for insertionsearchdeletion operations with just a fewlines of code that you still have to write yourself. Whereas storing the same information inside a static array of structsmay require On insertion searchdeletion, and you will need towrite the longer traversal code yourself.  .  lf. Balanced Binary Search Tree BST C STL mapset JavaTreeMapTreeSet The BST is one way to organize data in a treestructure. In each subtree rooted at x, the following BST propertyholds Items on the left subtree of x are smaller than x and items onthe right subtree of x are greater than or equal to x. This is essentially an application of the Divide and Conquer strategyalso see Section 3.3. Organizing the data like this see Figure 2.2allows for Olog n searchkey, insertkey, findMinfindMax,successorkeypredecessorkey, and deletekey since in the worstcase, only Olog n operations are required ina root-to-leaf scan see7, 5, 54, 12 for details. However, this only holds if the BST isbalanced.  d.  d.  d.Implementing bug-free balanced BSTs such as the Adelson-VelskiiLandis AVL12 or Red-Black RB13 Trees is a tedious task and isdifficult to achieve in a time-constrained contest environment unlessyou have prepared a code library beforehand, see Section9.29.Fortunately, C STL has map and set and Java has TreeMap andTreeSet which are usually implementations of the RB Tree whichguarantees that major BST operations likeinsertionssearchesdeletions are done in Olog n time.  ing These two C STL template classes or Java APIs, youcan save a lot of precious coding time during contests! The difference between these two data structures is simplethe C STL map and Java TreeMap stores key  data pairswhereas the C STLset and Java TreeSet only stores the key. For most contest problems, we use a map to really mapinformation instead of a set a set is only useful for efficientlydetermining the existence of a certain key. However, there is a small drawback. If we use the libraryimplementations, it becomes difficult or impossible to augment addextra information to the BST. Please attempt Exercise 2.3.5 and read Section 9.29 for moredetails.  ils.  TL priority queue Java PriorityQueueThe heap is another way to organize data in a tree. The Binary Heapis also a binary tree like the BST, except that it must be a complete14tree. Complete binary trees can be stored efficiently in a compact 1-indexed array of size n  1, which is often preferred to an explicit treerepresentation. For example, the array A  NA, 90, 19, 36, 17, 3, 25, 1, 2, 7 is thecompact array representation of Figure 2.3 with index 0 ignored. Onecan navigate from a certain index vertex j to its parent, left child, andright child by using simple index manipulation 2,2 xi, and 2xi 1, respectively. These index manipulations can be made faster using bitmanipulation techniques see Section 2.2 i  1, i  1, and i  1 1, respectively.  ectively.  ly. Instead of enforcing the BST property, the Max Heap enforces theHeap property in each subtree rooted at x, items on the left and rightsubtrees of x are smaller than or equal to x see Figure 2.3. This is also an application of the Divide and Conquer concept seeSection 3.3. The property guarantees that the top or root of theheap is always the maximum element. There is no notion of a searchin the Heap unlike BSTs. The Heap instead allows for the fast extraction deletion of themaximum element ExtractMax and insertion of new itemsInsertvboth of which can be easily achieved by in a Olog n root-to-leaf or leaf-to-root traversal, performing swapping operations tomaintain the Max Heap property whenever necessary see 7, 5, 54,12 for details.  ails.  details. The Max Heap is a useful data structure for modeling a PriorityQueue, where the item with the highest priority the maximumelement can be dequeued ExtractMax and a new item v can beenqueued Insertv, both in Olog n time. The implementation15 of priority queue is available in the C STLqueue library or Java PriorityQueue. Priority Queues are an important component in algorithms likePrims and Kruskals algorithms for the Minimum Spanning TreeMST problem see Section 4.3, Dijkstras algorithm for the Single-Source Shortest Paths SSSP problem see Section 4.4.3, and the ASearch algorithm see Section 8.2.5.  2.5. This data structure is also used to perform partial sort in the C STLalgorithm library. One possible implementation is by processing theelements one by one and creating a Max16 Heap of k elements,removing the largest element whenever its size exceeds k k is thenumber of elements requested by user. The smallest k elements canthen be obtained in descending order by dequeuing the remainingelements in the Max Heap. As each dequeue operation is Olog k,partial sort has On log k time complexity17. When k  n, thisalgorithm is equivalent to a heap sort. Note that although the timecomplexity of a heap sort is also On log n, heap sorts are oftenslower than quick sorts because heap operations access data storedin distant indices and are thus not cache-friendly.  dly.  