  However, many programming problems do have better-than-Complete-Search solutions as illustrated in the Section 3.1. Thus a Complete Search solution may receive a Time LimitExceeded TLE verdict. With proper analysis, you can determine the likely outcome TLEversus AC before attempting to code anything Table 1.4 in Section1.2.3 is a good starting point. If a Complete Search is likely to pass the time limit, then go aheadand implement one. This will then give you more time to work on harder problems inwhich Complete Search will be too slow.In lOl, you will usually need better problem solving techniques asComplete Search solutions are usually only rewarded with verysmall fractions of the total score in the subtask scoring schemes. Nevertheless, Complete Search should be used when you cannotcome up with a better solutionit will at least enable you to scoresome marks.  arks.  ou will usually need better problem solving techniques asComplete Search solutions are usually only rewarded with verysmall fractions of the total score in the subtask scoring schemes. Nevertheless, Complete Search should be used when you cannotcome up with a better solutionit will at least enable you to scoresome marks. Sometimes, running Complete Search on small instances of achallenging problem can help us to understand its structure throughpatterns in the output it is possible to visualize the pattern forsome problems that can be exploited to design a faster algorithm.Some combinatorics problems in Section 5.4 can be solved thisway. Then, the Complete Search solution can also act as a verifier forsmall instances, providing an additional check for the faster butnon-trivial algorithm that you develop.  lop.   After reading this section, you may have the impression thatComplete Search only works for easy problems and it is usually notthe intended solution for harder problems. This is not entirely true. There exist hard problems that are only solvable with creativeComplete Search algorithms. We have reserved those problems for Section 8.2.In the next two sections, we give several easier examples of thissimple yet possibly challenging paradigm.In Section 3.2.1, we give examples that are implementediteratively.In Section 3.2.2, we give examples on solutions that areimplemented recursively with backtracking. Finally, in Section 3.2.3, we provide a few tips to give yoursolution, especially  pecially  pecially your Complete Search solution, a better chanceto pass the required Time Limit. Iterative Complete Search Iterative Complete Search Two Nested Loops UVa 725 -Division Abridged problem statement Find and display all pairs of 5-digitnumbers that collectively use the digits 0 through 9 once each, suchthat the first number divided by the second is equal to an integer N,where2 SN S79. That is, abcde  fghij  N, where each letter represents a differentdigit. The first digit of one of the numbers is allowed to be zero, e.g.for N  62, we have 79546  01283  62 94736  01528  62.  2.    62. Quick analysis shows that fghij can only range from 01234 to98765 which is at most  100K possibilities. An even better bound for fghij is the range 01234 to 98765 N,which has at most  50K possibilities for N  2 and becomes smallerwith increasing N. For each attempted fghij, we can get abcde from fghij  N and thencheck if all 10 digits are different. This is a doubly-nested loop with a time complexity of at most 50Kx10  500K operations per test case.  est case.  est case.   case. This is small. Thus, an iterative Complete Search is feasible. Themain part of the code is shown below we use a fancy bitmanipulation trick shown in Section 2.2 to determine digituniqueness Iterative Complete Search Many Nested Loops UVa 441 - LottoIn programming contests, problems that are solvable with a singleloop are usually considered easy. Problems which require doubly-nested iterations like UVa 725 -Division above are more challenging but they are not necessarilyconsidered difficult. Competitive programmers must be comfortable writing code withmore than two nested loops.  ted loops. Lets take a look at UVa 441 which can be summarized as followsGiven 6 k  13 integers, enumerate all possible subsets of size 6 ofthese integers in sorted order. Since the size of the required subset is always 6 and the outputhas to be sorted lexicographically the input is already sorted, theeasiest solution is to use six nested loops as shown below. Note that even in the largest test case when k  12, these sixnested loops will only produce 12C6  924 lines of output. This is small. Iterative Complete Search Loops  Pruning UVa 11565 - SimpleEquations Abridged problem statement Given three integers A, B, and C 1sA,B,C  10000, find three other distinct integers x, y, and z suchthatxyzA,xxyxzB,andx2y2722C.  .  y222C. The third equation x2  y2  z2  Cis a good starting point.Assuming that C has the largest value of 10000 and y and z are oneand two x, y, z have to be distinct, then the possible range ofvalues for x is -100... 100. We can use the same reasoning to get a similar range for y and z. We can then write the following triply-nested iterative solutionbelow that requires 201 x 201 x 201  8M operations per test case. Notice the way a short circuit AND was used to speed up thesolution by enforcing a lightweight check on whether x, y, and z areall different before we check the three formulas. The code shown above already passes the required time limit forthis problem, but we can do better.  tter.  