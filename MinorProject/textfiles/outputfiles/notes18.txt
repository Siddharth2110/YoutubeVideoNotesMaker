 More advanced analysis techniques Prove the correctness of an algorithm especially for Greedyalgorithms in Section 3.4, to minimize your chance of getting theWrong Answer verdict. Perform the amortized analysis e.g. see Chapter 17 of 7although rarely used in conteststo minimize your chance ofgetting the Time Limit Exceeded verdict, or worse, consideringyour algorithm to be too slow and skips the problem when it is infact fast enough in amortized sense. Do output-sensitive analysis to analyze algorithm which alsodepends on output size and minimize your chance of getting theTime Limit Exceeded verdict. For example, an algorithm tosearch for a string with length m in a long string with the help of aSuffix Tree that is already built runs in Omocc time. The timetaken for this algorithm to run depends not only on the input sizem but also the output sizethe number of occurrences occ seemore details in Section 6.6.   6.6. Familiarity with these bounds 210  1, 024  103, 220  1, 048, 576  106. 32-bit signed integers int and 64-bit signed integers longlong have upper limits of 231-1  2x109 safe for up to  9decimal digits and 263-1  9x1018 safe for up to  18 decimaldigits respectively.     integers can be used if only non-negative numbersare required. 32-bit unsigned integers unsigned int and 64-bitunsigned integers unsigned long long have upper limits of 232-1  4x109 and 264 -1  1.8x1019 respectively. If you need to store integers  264, use the Big Integertechnique Section 5.3. There are n! permutations and 2n subsets or combinations ofn elements. The best time complexity of a comparison-based sortingalgorithm is Qn log2 n. Usually, On log2 n algorithms are sufficient to solve mostcontest problems. The largest input size for typical programming contestproblems must be  1M.Beyond that, the time needed to read the input the InputOutputroutine will be the bottleneck.A typical year 2013 CPU can process 100M  108 operations ina few seconds.  ce programmers would skip this phase andimmediately begin implementing the first algorithm that they canthink of only to realize that the chosen data structure or algorithmis not efficient enough or wrong. Our advice for ICPCcontestants6 Refrain from coding until you are sure that youralgorithm is both correct and fast enough. To help you understand the growth of several common timecomplexities, and thus help you judge how fast is enough, referto Table 1.4. Variants of such tables are also found in many otherbooks on data structures and algorithms. This table is writtenfrom a programming contestants perspective. Usually, the inputsize constraints are given in a good problem description.With the assumption that a typical CPU can execute a hundredmillion operations in around 3 seconds the typical time limit inmost UVa 47 problems, we can predict the worst algorithmthat can still pass the time limit. Usually, the simplest algorithmhas the poorest time complexity, but if it can pass the time limit,just use it!  !  ter Programming Languages There are several programming languages supported in ICPC7,including CC and Java. Which programming languages shouldone aim to master Our experience gives us this answer We prefer C with itsbuilt-in Standard Template Library STL but we still need tomaster Java. Even though it is slower, Java has powerful built-inlibraries and APIs such as BigIntegerBigDecimal,GregorianCalendar, Regex, etc. Java programs are easier to debug with the virtual machinesability to provide a stack trace when it crashes as opposed to coredumps or segmentation faults in CC. On theother hand, CC has its own merits as well. Depending on the problem at hand, either language may be thebetter choice for implementing a solution in the shortest time.   time. Suppose that a problem requires you to compute 25! thefactorial of 25. The answer is very large15,511,210,043,330,985,984,000,000. This far exceeds the largestbuilt-in primitive integer data type unsigned long long 264-1. As there is no built-in arbitrary-precision arithmetic library inCC as of yet, we would have needed to implement one fromscratch. The Java code, however, is exceedingly simple moredetails in Section 5.3. In this case, using Java definitely makes forshorter coding time.  ng time.  . Mastering and understanding the full capability of your favouriteprogramming language is also important. Take this problem with a non-standard input format the first lineof input is an integer N. This is followed by N lines, each starting with the character 0,followed by a dot , then followed by an unknown number ofdigits up to 100 digits, and finally terminated with three dots ... Not many CC programmers are aware of partial regexcapabilities built into the C standard IO library. Althoughscanfprintf are C-style IO routines, they can still be used in Ccode.  code.  code.  n Ccode. Many C programmers force themselves to use cincout allthe time even though it is sometimes not as flexible asscanfprintf and is also far slower.In programming contests, especially ICPCs, coding time shouldnot be the primary bottleneck. Once you figure out the worst ACalgorithm that will pass the given time limit, you are expected tobe able to translate it into a bug-free code and fast!  