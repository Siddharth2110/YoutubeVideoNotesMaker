  The root of segment tree represents segment 0, n-1. For eachsegment L, R stored in index p where L !R, the segment will besplit into L, LR2 and LR21, R in a left and right vertices. The left sub-segment and right sub-segment will be stored in index2xp and 2xp1 respectively. WhenL R, it is clear that stp  L orR. Otherwise, we will recursively build the segment tree, comparingthe minimum value of the left and the right sub-segments andupdating the stp of the segment. This process is implemented in the build routine below. This buildroutine creates up to O1248. . .2log2 n  O2n smallersegments and therefore runs in On. However, as we use simple 1-based compact array indexing, weneed st to be at least of size 2  2log2n1. In our implementation,we simply use a loose upper bound of space complexity O4n On.  .   O4n On. For array A above, the corresponding segment tree is shown inFigure 2.8 and 2.9. With the segment tree ready, answering an RMQ can be done inOlog n. The answer for RMQi, i is trivialsimply return i itself. However,for the general case RMQi, j, further checks are needed. Let pl  RMQi, ij2 and p2  RMQij2  1, j. Then RMQ, jis pl if Ap1  Ap2 or p2 otherwise. This process is implemented in the rmq routine below. Take forexample the query RMQ1, 3.  MQ1, 3. The process in Figure 2.8 is as follows Start from the root index 1which represents segment 0, 6. We cannot use the stored minimum value of segment 0, 6  st15 as the answer for RMQ1, 3 since it is the minimum value over alarger26 segment than the desired 1, 3. From the root, we only have to go to the left subtree as the root ofthe right subtree represents segment 4, 6 which is outside27 thedesired range in RMQ1, 3. We are now at the root of the left subtree index 2 thatrepresents segment 0, 3.   0, 3.   0, 3.   This segment 0, 3 is still larger than the desired RMQ1, 3. Infact, RMQ1, 3 intersects both the left sub-segment 0, 1 index 4and the right sub-segment 2, 3 index 5 of segment 0, 3, so wehave to explore both subtrees sub-segments. The left segment 0, 1 index 4 of 0, 3 index 2 is not yet insidethe RMQ1, 3, so another split is necessary. From segment 0, 1 index 4, we move right to segment 1, 1index 9, which is now inside28 1, 3. At this point, we know that RMQ1, 1  st9  1 and we canreturn this value to the caller. The right segment 2, 3 index 5 of 0, 3 index 2 is inside therequired 1, 3. From the stored value inside this vertex, we know that RMQ2, 3 st5  2. We do not need to traverse further down.  own.  down. Now, back in the call to segment 0, 3 index 2, we now have p1 RMAQ1, 1  1 and p2  RMQ2, 3  2. Because Ap1  Ap2 sinceA1  17 and A2  13, we now have RMQ1, 3  p2  2. This is thefinal answer. Now lets take a look at another example RMQ4, 6. Theexecution in Figure 2.9 is as follows We again start from the rootsegment 0, 6 index 1. Since it is larger than the RMQ4, 6, we move right to segment 4,6 index 3 as segment 0, 3 index 2 is outside.  e.  . Since this segment exactly represents RMQ4, 6, we simply returnthe index of minimum element that is stored in this vertex, which is5. Thus RMQ4, 6  st3  5. This data structure allows us to avoid traversing the unnecessaryparts of the tree! In the worst case, we have two root-to-leaf pathswhich is just O2xlog2n  Olog n. Example In RMQ3, 4  4, we have one root-to-leaf path from 0,6 to 3, 3 index 1  245  11 and another root-to-leaf pathfrom 0, 6 to 4, 4 index 13 6-2 12. If the array A is static i.e. unchanged after it is instantiated, thenusing a Segment Tree to solve the RMQ problem is overkill as thereexists a Dynamic Programming DP solution that requires On logn one-time pre-processing and allows for O1 per RMQ. This DPsolution will be discussed later in Section 9.33.  on 9.33.  n 9.33. Segment Tree is useful if the underlying array is frequentlyupdated dynamic. For example, if A5 is now changed from 11 to 99, then we justneed to update the vertices along the leaf to root path in Olog n.See path 5, 5 index 13, st13 is unchanged  4, 5 index 6,st6  4 now  4, 6 index 3, st3  4 now  0, 6 index 1, st1 2 now in Figure 2.10.For comparison, the DP solution presented in Section 9.33 requiresanother On log n pre-processing to update the structure and isineffective for such dynamic updates.    dates.Binary Indexed Fenwick TreeFenwick Treealso known as Binary Indexed Tree BITwereinvented by Peter M.Fenwick in 1994 . In this book, we will use the term Fenwick Tree asopposed to BIT in order to differentiate with the standard bitmanipulations. The Fenwick Tree is a useful data structure forimplementing dynamic cumulative frequency tables. Suppose wehave test scores of m 11 students f  2,4,5,5,6,6,6,7,7,8,9 wherethe test scores are integer values ranging from 1..10. Table 2.1shows the frequency of each individual test score 1..10 and thecumulative frequency of test scores ranging from 1..i denoted bycfithat is, the sum of the frequencies of test scores 1, 2, ..., i.    