  With Adjacency Lists, we can also enumerate the list of neighborsof a vertex v efficiently. If v has k neighbors, the enumeration willrequire Ok time. Since this is one of the most common operations in most graphalgorithms, it is advisable to use Adjacency Lists as your first choiceof graph representation. Unless otherwise stated, most graph algorithms discussed in thisbook use the Adjacency List.C. The Edge List, usually in the form of a vector of triples seeFigure 2.4. Using the C STL vector pairint, ii  EdgeList. Usingthe Java API Vector IntegerTriple  EdgeList. IntegerTriple is a classthat contains a triple of integers like pairint, ii above. In the Edge List, we store a list of all EF edges, usually in somesorted order. For directed graphs, we can store a bidirectional edgetwice, one for each direction.  .  ion.The space complexity is clearly OE. This graph representation isvery useful for Kruskals algorithm for MST Section 4.3.2, wherethe collection of undirected edges need to be sorted23 byascending weight. However, storing graph information in Edge List complicates manygraph algorithms that require the enumeration of edges incident toa vertex.Implicit Graph Some graphs do not have to be stored in a graph data structure orexplicitly generated for the graph to be traversed or operated upon.Such graphs are called implicit graphs.   graphs. You will encounter them in the subsequent chapters. Implicitgraphs can come in two flavours The edges can be determined easily. Example 1 Navigating a 2Dgrid map see Figure 2.5.A. The vertices are the cells in the 2D character grid where represents land and  represents an obstacle. The edges can bedetermined easily There is an edge between two neighboring cells in the grid if theyshare an NSEW border and if both are  see Figure 2.5.B.Example 2 The graph of chess knight movements on an 8x8chessboard.  rd.  rd.  ssboard. The vertices are the cells in the chessboard. Two squares in thechessboard have an edge between them if they differ by twosquares horizontally and one square vertically or two squaresvertically and one square horizontally. The first three rows and four columns of a chessboard are shownin Figure 2.5.C many other vertices and edges are not shown.The edges can be determined with some rules. Example A graph contains N vertices 1..N. There is an edgebetween two vertices i and j if ij isa prime. See Figure 2.5.D thatshows such a graph with N  5 and several more examples inSection 8.2.3.  8.2.3.  .2.3. Union-Find Disjoint Sets The Union-Find Disjoint Set UFDS is a data structure to model acollection of disjoint sets with the ability to efficiently24in O1determine which set an item belongs to or to test whethertwo items belong to the same set and to unite two disjoint sets intoone larger set.    a structure can be used to solve the problem of findingconnected components in an undirected graph Section 4.2.3.Initialize each vertex to a separate disjoint set. Then enumerate the graphs edges and join every twoverticesdisjoint sets connected by an edge. We can then test if two vertices belong to the samecomponentset easily. These seemingly simple operations are not efficiently supportedby the C STL set and Java TreeSet, which is not designed for thispurpose. Having a vector of sets and looping through each one to findwhich set an item belongs to is expensive! C STL set union inalgorithm will not be efficient enough although it combines twosets in linear time as we still have to deal with shuffling the contentsof the vector of sets! To support these set operations efficiently, we need a better datastructurethe UFDS.    UFDS. The main innovation of this data structure is in choosing arepresentative parent item to representa set. lf we can ensure that each set is represented by only one uniqueitem, then determining if items belong to the same set becomes farsimpler The representative parent item can be used as a sort of identifierfor the set.  he set.   To achieve this, the Union-Find Disjoint Set creates a tree structurewhere the disjoint sets form a forest of trees. Each tree correspondsto a disjoint set. The root of the tree is determined to be the representative itemfor a set. Thus, the representative set identifier for an item can beobtained simply by following the chain of parents to the root of thetree, and since a tree can only have one root, this representativeitem can be used as a unique identifier for the set. To do thisefficiently, we store the index of the parent item and the upperbound of the height of the tree of each set vi p and vi rank in ourimplementation. Remember that vi is our shortcut for a vector ofintegers. pi stores the immediate parent of item i. If item iis therepresentative item of a certain disjoint set, then pi i, i.e. a self-loop. ranki yields the upper bound of the height of the treerooted at item i.  item i.  