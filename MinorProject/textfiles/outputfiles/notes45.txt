  This graph traversal behavior can be implemented easily with therecursive code below. Our DFS implementation uses the help of a global vector ofintegers vi dfsnum to distinguish the state of each vertex. For the simplest DFS implementation, we only use vi dfsnum todistinguish between unvisited we use a constant value UNVISITED -1 and visited we use another constant value VISITED  1. Initially, all values in dfsnum are set to unvisited. We will use vi dfsnum for other purposes later. Calling dfsu startsDFS from a vertex u, marks vertex u as visited, and then DFSrecursively visits each unvisited neighbor v of u i.e. edge u - v existsin the graph and dfsnumv  UNVISITED. The time complexity of this DFS implementation depends on thegraph data structure used.Ina graph with V vertices and E edges, DFS runs in OV  E and OV2 if the graph is stored as Adjacency List and Adjacency Matrix,respectively.  vely.  ectively. On the sample graph in Figure 4.1, dfs0calling DFS from astarting vertex u  Owill trigger this sequence of visitation 0  13293794 This sequence is depth-first, i.e. DFS goes to the deepest possiblevertex from the start vertex before attempting another branch thereis none in this case. Note that this sequence of visitation depends very much on theway we order the neighbors of a vertex1, i.e. the sequence 0  153  2 backtrack to 3  4 is also a possible visitation sequence. Also notice that one call of dfsu will only visit all vertices that areconnected to vertex u. That is why vertices 5, 6, 7, and 8 in Figure 4.1 remain unvisitedafter calling dfs0.  fs0.  The DFS code shown here is very similar to the recursivebacktracking code shown earlier in Section 3.2. lf we compare the pseudocode of a typical backtracking codereplicated below with the DFS code shown above, we can see thatthe main difference is the flagging of visited vertices states. Backtracking automatically un-flag visited vertices reset the stateto previous state when the recursion backtracks to allow re visitationof those vertices states from another branch. By not revisiting vertices of a general graph via dfsnumchecks, DFS runs in OV  , but the time complexity of backtrackingis exponential.  . Breadth First Search BFS Breadth First Searchabbreviated as BFSis another graphtraversal algorithm. Starting from a distinguished source vertex, BFSwill traverse the graph breadth-first. That is, BFS will visit vertices that are direct neighbors of the sourcevertex first layer, neighbors of direct neighbors second layer, andso on, layer by layer. BFS starts with the insertion of the source vertex s into a queue,then processes the queue as follows  ws  ws  ows Take out the front most vertex u from the queue, enqueue allunvisited neighbors of u usually, the neighbors are ordered based ontheir vertex numbers, and mark them as visited. With the help of the queue, BFS will visit vertex s and all vertices inthe connected component that contains s ayer by layer. BFS algorithm also runs in OV E and OV 2 ona graphrepresented using an Adjacency List and Adjacency Matrix,respectively again, see Exercise 4.2.2.2. Implementing BFS is easy if we utilize C STL or Java API. We usequeue to order the sequence of visitation and vectorint or vi torecord if a vertex has been visited or notwhich at the same timealso record the distance layer number of each vertex from thesource vertex. This distance computation feature is used later to solve a specialcase of Single-Source Shortest Paths problem see Section 4.4 and8.2.3.  and8.2.3.  8.2.3. Finding Connected Components Undirected Graph DFS and BFS are not only useful for traversing a graph. They can beused to solve many other graph problems. The first few problems below can be solved with either DFS or BFSalthough some of the last few problems are more suitable for DFSonly.  only.  only.  Sonly. The fact that one single call of dfsu or bfsu will only visitvertices that are actually connected to u can be utilized to find andto count the number of connected components in an undirectedgraph see further below in Section 4.2.9 for a similar problem ondirected graph. We can simply use the following code to restart DFS or BFS fromone of the remaining unvisited vertices to find the next connectedcomponent. This process is repeated until all vertices have been visited and hasan overall time complexity of OV  E. Flood Fill - LabelingColoring the Connected Components DFS or BFS can be used for other purposes than just finding andcounting the number of connected components.  nents.  nts. Here, we show how a simple tweak of the OV  E dfsu we canalso use bfsu can be used to abel also known in CS terminology asto color and count the size of each component. This variant is more famously known as flood fill and usuallyperformed on implicit graphs usually 2D grids. Lets see an example below UVa 469 - Wetlands of Florida. Theimplicit graph is a 2D grid where the vertices are the cells in the gridand the edges are the connections between a cell and itsSSEENENNWWSW cells. W denotes a wet cell and LU denotesa land cell. Wet area is defined as connected cells labeled with W. We canlabel and simultaneously count the size of a wet area by usingfloodfill. The example below shows an execution of floodfill from row2, column 1 0-based indexing, replacing W to .  W to .  