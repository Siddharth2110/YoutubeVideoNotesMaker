 The key idea of Kadanes algorithm is to keep a running sum of theintegers seen so far and greedily reset that to 0 if the running sumdips below 0. This is because re-starting from 0 is always better than continuingfrom a negative running sum. Kadanes algorithm is the requiredalgorithm to solve this UVa 507 problem as n s 20K. Note that we can also view this Kadanes algorithm as a DP solution. At each step, we have two choices We can either leverage thepreviously accumulated maximum sum, or begin a new range. The DP variable dpi thus represents the maximum sum of a rangeof integers that ends with element Ali. Thus, the final answer is the maximum over all the values of dpiwherei 0..n-1. If zero-length ranges are allowed, then O must also be considered asa possible answer. The implementation above is essentially an efficient version thatutilizes the space saving trick discussed earlier.  earlier.  ier. How do we tackle this problem An initial approach might be thisComplete Search algorithm Try all possible cutting points. Before that, we have to select anappropriate state definition for the problem The intermediate sticks. We can describe a stick with its twoendpoints left and right. However, these two values can be very huge and this cancomplicate the solution later when we want to memoize their values. We can take advantage of the fact that there are only n1 smallersticks after cutting the original stick n times. The endpoints of each smaller stick can be described by 0, thecutting point coordinates, and .   .  s, and . Therefore, we will add two more coordinates so that A  0, theoriginal A, and  so that we can denote a stick by the indices of itsendpoints in A. We can then use these recurrences for cutleft, right, whereleftright are the leftright indices of the current stick w.r.t. A. Originally, the stick is described by left  0 and right  n1, i.e. astick with length 0..Icuti-1, i 0, Wi E1..n1  if left  1  right where left and rightare the indices in A, then we have a stick segment that does not needto be divided further.  r.  0, 7 E1..n1  if left  1  right where left and rightare the indices in A, then we have a stick segment that does not needto be divided further. Cutleft, right  mincutleft, i  cuti, right  Aright-AleftVi left1..right-1  try all possible cutting points and pick thebest. The cost of a cut is the length of the current stick, captured inAright-Aleft. The answer can be found at cut0, n1. Many real-life problems can be classified as graph problems. Somehave efficient solutions.Some do not have them yet. In this relatively big chapter with lotsof figures, we discuss graph problems that commonly appear inprogramming contests, the algorithms to solve them, and thepractical implementations of these algorithms.  rithms.  hms. We cover topics ranging from basic graph traversals, minimumspanning trees, single-sourceall-pairs shortest paths, network flows,and discuss graphs with special properties.In writing this chapter, we assume that the readers are alreadyfamiliar with the graph terminologies listed in Table 4.1.If you encounter any unfamiliar term, please read other referencebooks like 7, 58 or browse the Internet and search for thatparticular term. We also assume that the readers have read various ways torepresent graph information that have been discussed earlier inSection 2.4.1.  .1.  counter any unfamiliar term, please read other referencebooks like 7, 58 or browse the Internet and search for thatparticular term. We also assume that the readers have read various ways torepresent graph information that have been discussed earlier inSection 2.4.1. That is, we will directly use the terms like Adjacency Matrix,Adjacency List, Edge List, and implicit graph without redefining them. Please revise Section 2.4.1 if you are not familiar with these graphdata structures. Our research so far on graph problems in recent ACM ICPC Asiaregional contests reveals that there is at least one and possiblymore graph problems in an ICPC problem set. However, since the range of graph problems is so big, each graphproblem only has a small probability of appearance.    arance.So the question is Which ones do we have to focus on. In ouropinion, there is no clear answer for this question. If you want to do well in ACM ICPC, you have no choice but to studyand master all these materials. For IOI, the syllabus 20 restricts Ol tasks to a subset of materialmentioned in this chapter. This is logical as high school students competing in IOI are notexpected to be well-versed with too many problem-specificalgorithms.To assist the readers aspiring to take part in the IOI, we will mentionwhether a particular section in this chapter is currently outside thesyllabus.  bus.  us.Depth First Search DFS Depth First Searchabbreviated as DFSis a simple algorithm fortraversing a graph. Starting from a distinguished source vertex, DFS will traverse thegraph depth-first. Every time DFS hits a branching point a vertex with more than oneneighbors, DFS will choose one of the unvisited neighbors and visitthis neighbor vertex. DFS repeats this process and goes deeper until it reaches a vertexwhere it cannot go any deeper. When this happens, DFS willbacktrack and explore another unvisited neighbors, if any.   if any.  